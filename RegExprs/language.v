Require Export base.

(*Generalizable All Variables.*)

(** * Definition of languages. *)
(** In this script we define languages and prove the main lemmas related to their properties. *)

Definition word  := list Z.

Lemma word_leibniz :
  forall x y:word, x === y -> x = y.
Proof.
  induction 1;autotc;subst;inv H;auto.
Qed.

Definition WordPower (x:word)(n:nat) := list_pow _ x n.

Notation "x ^p n" := (@WordPower _ _ x n)(at level 60).
 
(** We use the library Ensembles for defining languages. *)

Definition language := Ensemble word.

  (* First we defined the set of all the words that can be generated by a given alphabet, i.e., Kleene's closure w.r.t and alphabet. *)

Notation "x ∈ y" := (@In _ y x)(at level 30).

Inductive sigma_star : language :=
| in_sigma_star_nil : [] ∈ sigma_star 
| in_sigma_star : forall w, w ∈ sigma_star -> forall a, (a::w) ∈ sigma_star.

Hint Constructors sigma_star : lang.

Notation "∑∗" := sigma_star.

(** We define the notion of well-formed languages, i.e., languages
which are subsets of [SigmaStar]. *)

Notation "x ⊆ y" := (Included _ x y)(at level 31).

Definition language_wf (L:language) := L ⊆ (sigma_star).

Definition empty_l := (@Empty_set (word)). 
Notation "∅" := (empty_l)(at level 0).
Hint Constructors Empty_set : lgs.
 
Definition eps_l := (Singleton word nil). 
Notation "'{ε}'" := eps_l.
Hint Constructors Singleton : lgs.

Inductive symb_l (s:Z) : language :=
| in_sing : forall x, x === s -> (x::nil) ∈ symb_l s. 
Notation "{{ S }}" := (symb_l S)(at level 0).
Hint Constructors symb_l : lgs.

Definition union_l (l l':language) := Union word l l'.
Infix "∪" := union_l(at level 59).
Hint Constructors Union : lgs.

Reserved Notation "x • y"  (at level 58,left associativity).
Inductive  conc_l (L1 L2:language) : language :=
| conc_l_app : 
  forall w1 w2, 
    w1 ∈ L1 -> w2 ∈ L2 -> (w1 ++ w2)%list ∈ (conc_l L1 L2).
Infix "•" := (conc_l).
Hint Constructors conc_l : lgs.

Reserved Notation "x •• n" (at level 45).
Fixpoint conc_ln (L:language)(n:nat) : language :=
  match n with
    | 0     => {ε} 
    | S m => L • (conc_ln L m)
  end.
Notation "x •• n" := (conc_ln x n).

Reserved Notation "x ∗" (at level 45).
Inductive star_l (l:language) : language :=
| starL_n : 
  forall n w,
    w ∈ (l •• n) -> w ∈  (star_l l). 
Notation "x ∗" := (star_l x).

Reserved Notation "x ⁺" (at level 45).
Inductive plus_l (l:language) : language :=
| starplus_l_n : 
  forall n w, 
    w ∈ (l •• S n) -> w ∈ (plus_l l) .
Notation "x ⁺" := (plus_l x).

Hint Constructors star_l plus_l : lgs.

Lemma _A_leibniz  : 
  forall a b:Z, 
    a === b -> a = b.
Proof.
  induction 1;auto.
Qed.

Definition leq (L1 L2:language) := Same_set (word) L1 L2. 
Notation "x ∼ y" := (leq x y)(at level 70).
Notation "x !∼ y" := (~(x ∼ y))(at level 70).

Section WellFormedLanguages.

  Lemma empty_l_wf : 
    language_wf ∅.
  Proof.
    do 2 red;intros;inversion H.
  Qed.

  Lemma eps_l_wf : 
    language_wf {ε}.
  Proof.
    do 2 red;intros;inversion_clear H;auto with lang.
  Qed.

  Lemma symb_l_wf : 
    forall s,
      language_wf {{s}}.
  Proof.
    do 2 red;intros;inversion_clear H;auto with lang.
  Qed.

  Lemma union_l_wf : 
    forall L1 L2:language,
    forall (H1:language_wf L1)(H2:language_wf L2),
      language_wf (L1 ∪ L2).
  Proof.
    unfold language_wf,Included;intros;
    inversion_clear H;auto.
  Qed.

  Lemma conc_l_wf : 
    forall L1 L2:language,
    forall (H1:language_wf L1)(H2:language_wf L2),
      language_wf (L1 • L2).
  Proof.
    unfold language_wf,Included;intros;
    inversion_clear H;auto.
    apply H1 in H0;apply H2 in H3.
    induction H0;try assumption.
    rewrite <- app_comm_cons;auto with lang.
  Qed.

  Lemma conc_ln_0 : 
    forall l,
      (l •• 0) = {ε}.
  Proof.
    reflexivity.
  Qed.

  Lemma conc_ln_n : 
    forall l n,
      (l •• (n+1)) = (l • (l •• n)).
  Proof.
    intros.
    replace (n + 1) with (S n);[reflexivity|abstract(omega)].
  Qed.

  Lemma conc_ln_wf : 
    forall L n,
    forall (H:language_wf L),
      language_wf (L •• n).
  Proof.
    induction n;unfold language_wf,Included;
    simpl;intros;
    inversion_clear H0;auto with lang.
    generalize (IHn H).
    intro.
    generalize(conc_l_wf);intro.
    eapply H3 with (L1:=L)(L2:=(L••n));auto with lgs.
  Qed.

  Lemma star_l_wf : 
    forall L, 
    forall (H:language_wf L), 
      language_wf (L∗).
  Proof.
    unfold language_wf,Included;intuition.
    inversion_clear H0.
    generalize(conc_ln_wf);intro J;unfold language_wf,Included in J.
    eapply J with (x:=x)(n:=n) in H;auto.
  Qed.
  
  Lemma plus_l_wf :
    forall L (H:language_wf L), 
      language_wf (L⁺).
  Proof.
    unfold language_wf,Included;intuition.
    inversion_clear H0.
    generalize(conc_ln_wf);intro J;unfold language_wf,Included in J.
    eapply J with (x:=x)(n:=(S n)) in H;auto.
  Qed.

End WellFormedLanguages.

(** Some automation into regular language reasoning *)

Hint Extern 1 (?L1 ∼ ?L2) => 
  match goal with 
    | H:L2 ∼ L1 |- _ => symmetry;auto
    | _ => match constr:(L1 = L2) with
             | ?X = ?X => reflexivity
             | _ => idtac
           end
  end.

Hint Extern 4 ([] ∈ {ε}) => constructor.

Hint Extern 1 (?x ∈ ?X) =>
  match goal with 
    | H: X ∼ ?Y , H1: x ∈ ?Y |- _ => apply H;apply H1
    | H: ?Y ∼ X , H1: x ∈ ?Y |- _ => apply H;apply H1
  end.

Hint Extern 1 (?X ⊆ ?Z) =>
  match constr:(X = Z) with
    | ?K = ?K  => repeat red;intros;auto
    | _ => 
      match goal with 
        | H : X ⊆ ?Y , H1 : ?Y ⊆ Z |- _ => red;intros;eauto
        | _ => idtac
      end
  end.

(** Now we register [leq] as a equivalence relation, and the constructions over languages as morphisms in order to perform general rewriting in the rest of the proofs involving languages. *)

Global Instance leq_equiv : Equivalence leq.
Proof.
  constructor;unfold leq;
  [unfold Reflexive|unfold Symmetric|unfold Transitive].
  (* reflexivity *)
  split;auto with sets.
  (* symmetry *)
  split;apply H.
  (* transitivity *)
  split;intros;
  inversion H;
  inversion H0;auto.
Qed.

Global Instance symb_l_m  : Proper(eq ==> leq) (symb_l).
Proof.
  repeat red;intros;split;red;intros;
  invc H0;constructor;
  [rewrite H in H1|rewrite H];auto.
Qed.


Global Instance union_l_m  : Proper(leq ==> leq ==> leq) union_l.
Proof.
  repeat red.
  intuition;
  red;intros;
  destruct H1;
    first [left;apply H;assumption|right;apply H0;assumption].
Qed.

Global Instance conc_l_m : Proper(leq ==> leq ==> leq) conc_l.
Proof.
  intros.
  split;unfold Included;intros;
  destruct H1;
  constructor;auto;
  first [apply H|apply H0];auto.
Qed.

Global Instance conc_ln_m : Proper(leq ==> _eq ==> leq) conc_ln.
Proof.
  repeat red.
  intros x y Hxy.
  intros.
  inv H.
  clear H.
  induction y0;split;intros.
  simpl;red;auto.
  simpl;red;auto.
  destruct IHy0.
  simpl.
  eapply conc_l_m;auto with lgs.
  split;auto.
  destruct IHy0.
  simpl.
  apply conc_l_m;eauto.
  split;auto.
Qed.

Global Instance star_l_m  : Proper(leq ==> leq) star_l.
Proof.
  repeat red.
  intros x y.
  split;unfold Included;intros;destruct H0;revert n w H0;induction n;simpl;intros;
  (match goal with 
      | H: _ ∈ {ε} |- _ => 
          now(invc H0;constructor 1 with 0)
      | H : _ ∈ (_ • _) |- _ => 
          let x1 := fresh w in
            let x2 := fresh w in
              destruct H as [x1 x2];
          match goal with
            | H' : _ ∈ (_ •• ?N) |- _ => 
                constructor 1 with (S N);simpl;constructor;auto;revert H';apply conc_ln_m;auto
          end
  end).
Qed.

Global Instance plus_l_m : Proper(leq ==> leq) plus_l.
Proof.
  repeat red.
  split;unfold Included;intros;destruct H0;revert n w H0;induction n;simpl;intros; 
  match goal with 
      (* Solve the base case *)
      | H: _ ∈ (_ • {ε}) |- _ => invc H;
          match goal with 
            | H' : _ ∈ {ε} |- _ => 
                invc H';constructor 1 with 0;constructor;simpl;auto with lang
          end
      (* Solve the inductive case *)
      | H : _ ∈ (_ • _) |- _ => 
          let x1 := fresh w in
            let x2 := fresh w in
              destruct H as [x1 x2];
          match goal with
            | H' : _ ∈ ( _ • (_ •• ?N)) |- _ =>
                invc H';
              constructor 1 with (S N);simpl;constructor;auto with lang;
              match goal with
                | H'' :  _ ∈ (_ •• ?N) |- _ =>
                    constructor;auto with lang;revert H'';eapply conc_ln_m;eauto
              end
          end
      | _ => idtac
  end;try (symmetry;auto).
Qed.                                           

Hint Resolve 
     @empty_l_wf
     @eps_l_wf
     @symb_l_wf
     @union_l_wf
     @conc_l_wf
     @conc_ln_0 
     @conc_ln_n
     @conc_ln_wf
     @star_l_wf 
     @plus_l_wf : lgs.

(** * Less-than relation for languages. *)

Definition lleq (L1 L2:language) := (L1 ∪ L2) ∼ L2.

Notation "x ≤ y" := (lleq x y)(at level 70).

Global Instance lleq_m : Proper(leq ==> leq ==> iff) lleq.
Proof.
  repeat red.
  split;unfold lleq;intros;
  [rewrite <- H, <- H0 | rewrite H,H0];
  assumption.
Qed.

Hint Resolve lleq_m : lang.

Global Instance union_l_lleq : Proper(lleq ==> lleq ==> lleq) union_l.
Proof.
  repeat red;unfold Included;split;intros;destruct H1.
  destruct H1.
  left;apply H;left;assumption.
  right;apply H0;left;assumption.
  assumption.
  right;left;assumption.
  right;right;assumption.
Qed.

Global Instance conc_l_lleq :  Proper(lleq ==> lleq ==> lleq) conc_l.
Proof.
  repeat red;unfold Included;split;intros;
  destruct H1.
  destruct H1;constructor;try (apply H;auto;left;auto).
  apply H0;left;auto.
  assumption.
  constructor 2;constructor;auto.
Qed.

Global Instance star_l_lleq :  Proper(lleq ==> lleq) star_l.
Proof.
  repeat red;unfold Included;split;intros.
  destruct H0.
  destruct H0.
  constructor 1 with n.
  revert n w H0.
  induction n;simpl;intros;try assumption.
  destruct H0.
  constructor.
  apply H;left;assumption.
  apply IHn;assumption.
  assumption.
  right;assumption.
Qed.     

(** Specification of a regular language. *)

Inductive rl : language -> Prop :=
| rl0 : rl ∅
| rl1 : rl {ε}
| rlsy : forall a, rl {{a}}
| rlp : forall l1 l2, rl l1 -> rl l2 -> rl (l1 ∪ l2)
| rlc : forall l1 l2, rl l1 -> rl l2 -> rl (l1 • l2)
| rlst : forall l, rl l -> rl (l∗).

(** * Definition of left-quotients of a language *) 

(** Quotient wrt. a symbol. *)

Reserved Notation "x %Lq y" (at level 60).
Inductive LQ (l:language) : Z -> language :=
| in_quo : forall x a, (a::x) ∈ l -> x ∈ (LQ l a).
Notation "x %Lq y" := (LQ x y).

(** Quotient wrt. a word. *)

Reserved Notation "x %Lqw y" (at level 60).
Inductive LQw (l:language) : word -> language :=
| in_quow : forall x w, (w ++ x)%list ∈ l -> x ∈ (LQw l w).
Notation "x %Lqw y" := (LQw x y).

Hint Constructors LQ LQw : lgs.

Global Instance LQ_m : Proper( leq ==> eq ==> leq) LQ.
Proof.
  repeat red.
  intros;subst;
  split;red;intros;
  inversion_clear H0;constructor;
  apply H;auto.
Qed.

Global Instance LQw_m : Proper(leq ==> eq ==> leq) LQw.
Proof.
  repeat red.
  induction 2;
  split;red;intros;
  inversion_clear H0;econstructor;
  apply H;auto.
Qed.

Global Instance LQ_m_m : Proper( leq ==> _eq ==> leq) LQ.
Proof.
  repeat red;intros;invc H0;split;red;intros;invc H0;constructor;autotc.
Qed.

Global Instance LQw_m_m : Proper(leq ==> _eq ==> leq) LQw.
Proof.
  repeat red;induction 2;split;red;intros;try (now(invc H0;constructor;autotc));
  inv H0;invc H2;constructor;apply word_leibniz in H1;subst;apply H;autotc. 
Qed.


